# Script to fix tailor.py
with open('tailor.py', 'r', encoding='utf-8') as f:
    lines = f.readlines()

# Keep lines before extract_text_from_docx (0-137)
new_lines = lines[:137]

# Add fixed extract_text_from_docx function
new_lines.append('def extract_text_from_docx(docx_path: str) -> str:\r\n')
new_lines.append('    from docx.oxml.ns import qn\r\n')
new_lines.append('    doc = Document(docx_path)\r\n')
new_lines.append('    full_text = []\r\n')
new_lines.append('\r\n')
new_lines.append('    # Track processed elements to avoid duplicates (especially in merged cells)\r\n')
new_lines.append('    processed_elements = set()\r\n')
new_lines.append('\r\n')
new_lines.append('    def get_cell_id(cell):\r\n')
new_lines.append('        # Use the memory address of the internal XML element as a proxy for identity\r\n')
new_lines.append('        return id(cell._element)\r\n')
new_lines.append('\r\n')
new_lines.append('    # 1. Headers (often contain contact info)\r\n')
new_lines.append('    for section in doc.sections:\r\n')
new_lines.append('        # Header Paragraphs\r\n')
new_lines.append('        for para in section.header.paragraphs:\r\n')
new_lines.append('            if para.text.strip() and id(para._element) not in processed_elements:\r\n')
new_lines.append('                full_text.append(para.text)\r\n')
new_lines.append('                processed_elements.add(id(para._element))\r\n')
new_lines.append('        \r\n')
new_lines.append('        # Header Tables\r\n')
new_lines.append('        for table in section.header.tables:\r\n')
new_lines.append('            for row in table.rows:\r\n')
new_lines.append('                for cell in row.cells:\r\n')
new_lines.append('                    if get_cell_id(cell) in processed_elements:\r\n')
new_lines.append('                        continue\r\n')
new_lines.append('                    processed_elements.add(get_cell_id(cell))\r\n')
new_lines.append('                    for para in cell.paragraphs:\r\n')
new_lines.append('                        if para.text.strip():\r\n')
new_lines.append('                            full_text.append(para.text)\r\n')
new_lines.append('\r\n')
new_lines.append('    # 2. Body Paragraphs\r\n')
new_lines.append('    for para in doc.paragraphs:\r\n')
new_lines.append('        if para.text.strip() and id(para._element) not in processed_elements:\r\n')
new_lines.append('            full_text.append(para.text)\r\n')
new_lines.append('            processed_elements.add(id(para._element))\r\n')
new_lines.append('            \r\n')
new_lines.append('    # 3. Body Tables\r\n')
new_lines.append('    for table in doc.tables:\r\n')
new_lines.append('        for row in table.rows:\r\n')
new_lines.append('            for cell in row.cells:\r\n')
new_lines.append('                # Content of merged cells is repeated in each cell of the range\r\n')
new_lines.append('                # We track unique cells to print content only once\r\n')
new_lines.append('                if get_cell_id(cell) in processed_elements:\r\n')
new_lines.append('                    continue\r\n')
new_lines.append('                processed_elements.add(get_cell_id(cell))\r\n')
new_lines.append('                \r\n')
new_lines.append('                for para in cell.paragraphs:\r\n')
new_lines.append('                    if para.text.strip():\r\n')
new_lines.append('                        full_text.append(para.text)\r\n')
new_lines.append('\r\n')
new_lines.append('    # 4. Textboxes (w:txbxContent)\r\n')
new_lines.append('    for element in doc.element.body.iter():\r\n')
new_lines.append('       if element.tag.endswith(\'txbxContent\'):\r\n')
new_lines.append('           for p in element.findall(qn(\'w:p\')):\r\n')
new_lines.append('               text = ""\r\n')
new_lines.append('               for r in p.findall(qn(\'w:r\')):\r\n')
new_lines.append('                   for t in r.findall(qn(\'w:t\')):\r\n')
new_lines.append('                       if t.text: text += t.text\r\n')
new_lines.append('               if text.strip():\r\n')
new_lines.append('                   full_text.append(text)\r\n')
new_lines.append('\r\n')
new_lines.append('    return \'\\n\'.join(full_text)\r\n')
new_lines.append('\r\n')
new_lines.append('# Removed extract_text_from_pdf dependency to ensure Sync\r\n')
new_lines.append('\r\n')

# Add remaining lines after the old function (starting from analyze_gaps at line 215)
new_lines.extend(lines[214:])

with open('tailor.py', 'w', encoding='utf-8') as f:
    f.writelines(new_lines)

print("Successfully updated tailor.py")
